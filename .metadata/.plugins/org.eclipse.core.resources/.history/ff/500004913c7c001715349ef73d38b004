package java_dzien_czwarty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Inne_typy_sekwencyjne {

	public static void main(String[] args) {
		
		// Typy sekwencyjne:
		
		// 1. Listy
		
		// Aby stosowaæ listy musimy zaimportowaæ bibliotekê list.
		// zasada jest bardzo podobna do tabel, jednak operacje przeprowadzane na listach wykonuje siê inaczej
		// UWAGA!!! deklarowanie listy danego typu odbywa siê poprzez umieszczenie typu w nawiasach ostrych <>
		
		ArrayList<String> lista1 = new ArrayList<String>(); // deklarowanie pustej listy typu string o nazwie lista1
		
		lista1.add("Ala"); // dodanie stringu do naszej lista1 na pozycjê o indeksie  0
		lista1.add("Ola"); // równie¿ dodanie, zawsze dodaje do listy od koñca czy na pozycjê o indeksie 1
		lista1.add("Ala"); // równie¿ dodanie itd o indeksie 2

		lista1.get(2); // polecenie wydobywa z listy zapisanego w niej tekstu pod indeksem 2
		
		System.out.println(lista1.get(2)); 
		
		System.out.println(lista1); // wyœwietlenie zawartoœci ca³ej listy w postaci tabli
		
		// pêtla do wyœwietlania zawartoœci listy 
		
		for (String s: lista1){
			System.out.print(s + " "); 
		}
		
		System.out.println("\nWilekoœæ listy: " + lista1.size()); // polecenie do wyœwietlenia wielkoœci listy
		
		lista1.remove(1); // usuwanie pozycji z lity pod konkretnym indeksem
		System.out.println(lista1);
		
		lista1.remove("Ala"); // usuwanie pozycji poprzez wpisanie bezpoœredniego tekstu jaki taki jaki wystêpuje w liœcie. UWAGA!!! je¿eli liest kilka takich samych to usunie pierwszy który znajdzie
		System.out.println(lista1);
		
		lista1.set(0, "Ela"); // modyfikacje pozycji pod konkretnym indeksem, który istnieje w liœcie
		System.out.println(lista1);
		
//		lista1.set(1, "Ola"); // je¿eli chcemy zmodyfikowaæ indeks który nie istnieje to wyrzuca nam b³¹d
		
		lista1.add(0, "Ola"); // dodaje do listy kolejn¹ zawartoœæ pod konkretny indeks. Je¿eli coœ siê tam znajdowa³o to przesunie ca³¹ lista o jeden w lewo tak aby pod tym indeksem który chcemy wstawiæ nowy element
		System.out.println(lista1);
		
		// 2. Zbiory
		
		// Aby stosowaæ zbiory musimy zaimportowaæ bibliotekê zbiorów.
		// zasada jest bardzo podobna do tabel, jednak operacje przeprowadzane na zbiorach wykonuje siê inaczej
		// UWAGA!!! deklarowanie zbioru danego typu odbywa siê poprzez umieszczenie typu w nawiasach ostrych <>
		// Zbiory nie s¹ indeksowane, nie mo¿emy 
		
		HashSet<Integer> zbior = new HashSet<Integer>(); // deklaracja pustego ziobru typu integer
		
		zbior.add(2); // dodanie do zbioru naszej liczby integer
		zbior.add(5); // te¿ dodanie
		zbior.add(1); // te¿ dodanie 
		zbior.add(1); // te¿ dodanie
		
		System.out.println(zbior); // UWAGA!!! w³aœciwoœci¹ zioru jest to, ¿e je¿eli wprowadzamy liczby nie pokolei i na dodatek s¹ jakieœ zdublowane wartoœci to zbiory dodatkowo sortuj¹ i usuwaj¹ duplikaty. Do zbiorów nie ma znaczenia kolejnoœæ dodawania elementów
		
		HashSet<Integer> zbior2 = new HashSet<Integer>();
		zbior2.add(9);
		zbior2.add(8);
		zbior2.add(7);
		zbior2.addAll(zbior); // dodanie do jednego zbioru innego zbioru i od razu dokonywana jest sortowanie nie ma znaczenia czy coœ by³o wprwadzane wczesniej itd
		System.out.println(zbior);
		System.out.println(zbior2);
		
		HashSet<String> zbior3 = new HashSet<String>(); // zbiory mog¹ byæ równie¿ stringowe, podobno je sortuje alfabetycznie
		zbior3.add("Tomek");
		zbior3.add("Piotrek");
		zbior3.add("Ala");
		System.out.println(zbior3);
		System.out.println(zbior3.contains("Ala")); // sprawdzenie czy w zbiorze coœ siê znajduje, zwraca true / false
		System.out.println(zbior2.contains(8));
		System.out.println(zbior3.size()); // sprawdzenie wielkoœci zbioru
		
		System.out.println(zbior3.remove("Ala")); // operacja remove zwraca wartoœæ true/false poniewa¿ mo¿emy chcec usun¹æ cos czego nie ma, wtedy zwroci false, je¿eli usuniemy coœ cos jest to zwroci true
		zbior3.remove("Ala"); // usuniêcie elementu ze zbioru
		System.out.println(zbior3);
		zbior3.clear(); // czyszczenie zbioru
		System.out.println(zbior3);
		
		// 3. Mapy
		// Aby stosowaæ mapy musimy zaimportowaæ bibliotekê map.
		// UWAGA!!! deklarowanie mapy danego typu odbywa siê poprzez umieszczenie typu w nawiasach ostrych <> zarówno typu klucza jak i jakiego typu bed¹ wartoœci wprowadzane wartoœci
		
		HashMap<Integer,String> mapa = new HashMap<Integer,String>();
		
		mapa.put(1, "Tomek"); // umieszczanie wartoœci w mapie z przypisanymi do niej kluczami
		mapa.put(2, "Olga"); // to równie¿ umieszczanie w mapie, nale¿y pamiêtaæ o s³ówku put
		System.out.println(mapa);
		
		System.out.println(mapa.get(1)); // dostanie siê do odpowiedniej wartoœci w mapie wpraowadzamy klucz jaki zosta³ jej przypisany. Je¿eli bêdziemy chceli siê odnieœæ do  nieistniej¹cego klucza dostaniemy zwrot null
		System.out.println(mapa.keySet()); // wypisuje klucze jakie znajduja siê w mapie
		System.out.println(mapa.values()); // wypisuje wartoœci jakie znajduj¹ siê w mapie
		mapa.remove(1, "Tomek"); // usuwa klucz wraz z wartoœci¹ do niej przypisan¹
		
		
		
	}

}
